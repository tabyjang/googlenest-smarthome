---
phase: 01-testing-infrastructure
type: execute
---

<objective>
Write initial component tests for Navigation and ProductCard to validate test infrastructure.

Purpose: Prove test framework works with real components, establish testing patterns for future work.
Output: Two passing test files demonstrating React Testing Library usage.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-testing-infrastructure/01-01-SUMMARY.md
@components/layout/Navigation.tsx
@components/products/ProductCard.tsx
@.planning/codebase/CONVENTIONS.md

**Testing Infrastructure Ready:**
- Vitest + React Testing Library configured (Plan 01-01 complete)
- jsdom environment, jest-dom matchers available
- Test scripts: npm test, npm test:ui

**Component Patterns:**
- React.FC functional components
- PascalCase.tsx files next to components
- Test files: ComponentName.test.tsx (co-located with components)

**What to Test:**
- Navigation: Renders links, routing works
- ProductCard: Displays product info, pricing formatted correctly
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Navigation component test</name>
  <files>components/layout/Navigation.test.tsx</files>
  <action>Create test file `components/layout/Navigation.test.tsx`:

Test structure (React Testing Library pattern):
1. Import render, screen from @testing-library/react
2. Wrap component in MemoryRouter (react-router-dom) for routing context
3. Test: Navigation renders all expected links
4. Test: Links have correct href attributes

Example test (adapt to actual Navigation component):
```typescript
import { render, screen } from '@testing-library/react';
import { MemoryRouter } from 'react-router-dom';
import Navigation from './Navigation';

describe('Navigation', () => {
  it('renders all navigation links', () => {
    render(
      <MemoryRouter>
        <Navigation />
      </MemoryRouter>
    );

    expect(screen.getByRole('link', { name: /products/i })).toBeInTheDocument();
    expect(screen.getByRole('link', { name: /experience/i })).toBeInTheDocument();
    // Add other expected links
  });

  it('links have correct paths', () => {
    render(
      <MemoryRouter>
        <Navigation />
      </MemoryRouter>
    );

    expect(screen.getByRole('link', { name: /products/i })).toHaveAttribute('href', '/products');
    // Verify other link paths
  });
});
```

Key patterns:
- Use `screen.getByRole('link')` for links (accessibility-focused queries)
- MemoryRouter wrapper for any component using React Router
- Case-insensitive text matching with `/text/i` regex
- jest-dom matchers: toBeInTheDocument(), toHaveAttribute()

Do NOT test implementation details (CSS classes, internal state). Test user-visible behavior only.
  </action>
  <verify>npm test -- Navigation.test.tsx shows 2 passing tests</verify>
  <done>Navigation test file exists, all tests pass, follows React Testing Library patterns</done>
</task>

<task type="auto">
  <name>Task 2: Create ProductCard component test</name>
  <files>components/products/ProductCard.test.tsx</files>
  <action>Create test file `components/products/ProductCard.test.tsx`:

ProductCard likely receives product data as props. Test structure:
1. Create mock product data (name, price, description, imageUrl)
2. Render ProductCard with mock data
3. Test: Product name renders
4. Test: Price displays (check formatting if applicable)
5. Test: Image has correct alt text (accessibility)

Example test (adapt to actual ProductCard props):
```typescript
import { render, screen } from '@testing-library/react';
import ProductCard from './ProductCard';

const mockProduct = {
  id: 'test-1',
  name: 'Google Nest Hub',
  price: 99000,
  description: 'Smart display',
  imageUrl: '/assets/nest-hub.jpg',
  category: 'display' as const,
};

describe('ProductCard', () => {
  it('renders product name', () => {
    render(<ProductCard product={mockProduct} />);
    expect(screen.getByText('Google Nest Hub')).toBeInTheDocument();
  });

  it('displays price correctly', () => {
    render(<ProductCard product={mockProduct} />);
    // Adjust based on actual price formatting (e.g., "₩99,000" or "99,000원")
    expect(screen.getByText(/99,000/)).toBeInTheDocument();
  });

  it('image has accessible alt text', () => {
    render(<ProductCard product={mockProduct} />);
    const img = screen.getByAltText(/Google Nest Hub/i);
    expect(img).toHaveAttribute('src', mockProduct.imageUrl);
  });
});
```

Key patterns:
- Mock data matches TypeScript types from types.ts
- Use `getByText` for text content, `getByAltText` for images
- Test accessibility (alt text, proper semantic HTML)
- Test what users see, not how component works internally

If ProductCard structure differs, adapt tests accordingly by reading the component first.
  </action>
  <verify>npm test -- ProductCard.test.tsx shows 3 passing tests</verify>
  <done>ProductCard test file exists, all tests pass, covers key rendering behaviors</done>
</task>

<task type="auto">
  <name>Task 3: Run full test suite and verify</name>
  <files>N/A (verification only)</files>
  <action>Run complete test suite and verify all tests pass:

1. Run tests:
```bash
npm test
```

Expected output: 5 total tests (2 Navigation + 3 ProductCard), all passing.

2. Verify test coverage structure works (don't require coverage targets yet):
```bash
npm run test:coverage
```

Should generate coverage/ directory (OK if coverage is low - Phase 1 is infrastructure setup).

3. Check build still works:
```bash
npm run build
```

Should complete without errors.

If any tests fail:
- Read error messages carefully
- Check component structure matches test expectations
- Verify MemoryRouter is used for routing components
- Ensure mock data matches component prop types

If build fails:
- Check for import errors in test files
- Verify vitest config doesn't conflict with build config
  </action>
  <verify>npm test shows "5 passed", npm run build succeeds</verify>
  <done>All tests passing, build works, testing infrastructure validated</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] npm test shows all tests passing (5 total)
- [ ] npm run build succeeds without errors
- [ ] No TypeScript errors in test files
- [ ] Test files follow project naming conventions (*.test.tsx)
- [ ] Tests use accessibility-focused queries (getByRole, getByLabelText)
</verification>

<success_criteria>

- Navigation.test.tsx created with 2 passing tests
- ProductCard.test.tsx created with 3 passing tests
- All 5 tests pass when running npm test
- Tests follow React Testing Library best practices
- Build process unaffected by test files
- Testing patterns established for future component tests
- Phase 1 complete: Testing infrastructure ready for use
  </success_criteria>

<output>
After completion, create `.planning/phases/01-testing-infrastructure/01-02-SUMMARY.md`:

# Phase 1 Plan 2: Initial Component Tests Summary

**Navigation and ProductCard tests validate test infrastructure is working**

## Accomplishments

- Created Navigation.test.tsx (2 tests: link rendering, correct paths)
- Created ProductCard.test.tsx (3 tests: name, price, image accessibility)
- All 5 tests passing
- Established React Testing Library patterns for future tests
- Verified build process unaffected by test infrastructure

## Files Created/Modified

- `components/layout/Navigation.test.tsx` - Created with 2 tests
- `components/products/ProductCard.test.tsx` - Created with 3 tests

## Decisions Made

- **Test Co-Location**: Test files next to components (not separate __tests__ directory)
- **Router Mocking**: MemoryRouter for components using React Router
- **Query Priority**: Accessibility-focused queries (getByRole, getByAltText) over getByTestId
- **Mock Data**: Inline mock objects matching TypeScript types

## Testing Patterns Established

- Wrap routing components in MemoryRouter
- Use semantic queries (getByRole('link'), getByAltText())
- Test user-visible behavior, not implementation
- Mock data matches TypeScript interfaces

## Issues Encountered

[Document any issues, or "None"]

## Next Phase Readiness

**Phase 1 Complete!** Testing infrastructure is ready.

Next: Phase 2 - Error Handling
- Can now test error boundaries
- Can verify loading states
- Can test error message rendering

Recommendations for future tests:
- VoiceExperience: Mock fetch calls to /api/gemini
- Room Planner: Test drag-and-drop with @testing-library/user-event
- EstimatorForm: Test form validation and calculations
</output>
